#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int Repeat(char**, char*, char *, int, int);

int main()
{
	char** str = 0;
	char *str_dop = 0, *str_res = 0;
	int n, m, n1, size, is_matched = 0;
	do                             //цикл пока не будет выделена память под строки
	{
		system("CLS");
		printf_s("Enter the number of sentences: ");
		if (!(scanf_s("%d", &n)))
		{
			rewind(stdin);
			continue;
		}
		str = (char**)malloc(n * sizeof(char*));
		if (!str)
		{
			free(str);
			continue;
		}
		printf_s("Allocate memory for sentences: ");
		if (!(scanf_s("%d", &m)))
		{
			rewind(stdin);
			continue;
		}
		for (int i = 0; i < n; i++)
		{
			*(str + i) = (char*)malloc(m * sizeof(char));
			if (!*(str + i))
			{
				for (int j = 0; j < i; j++)
				{
					free(*(str + j));
				}
				free(str);
				str = 0;
				break;
			}
		}
		printf_s("Allocate memory for the final array of matched words: ");
		if (!(scanf_s("%d", &n1)))
		{
			rewind(stdin);
			continue;
		}
		str_res = (char*)malloc(n1 * sizeof(char));      //выделяем память под результирующую строку
		if (!str_res)
		{
			free(str_res);
			continue;
		}
		printf_s("Allocate memory for the additional line: ");
		scanf_s("%d", &size);
		str_dop = (char*)malloc(size * sizeof(char));   //выделяем память под дополнительную строк для записи в неё
		if (!str_dop)                                   //слов для дальнейшего поиска их совпадений 
		{
			free(str);
			continue;
		}
	} while (!str && !str_dop && !str_res);
    
	rewind(stdin);
	for (int i = 0; i < n; i++)
	{
		printf_s("Line #%d: ", i + 1);
		fgets(*(str + i), m, stdin);
	}
    
	rewind(stdin);
	is_matched = Repeat(str, str_res, str_dop, n, m);
	if (is_matched == 0)              //не найдено совпадений
	{
		printf_s("No matching words were found.");
	}
	else
	{
		printf_s("The final array: ");
		printf_s("%s", str_res);
	}
	free(str_dop);                                    //освобождаем выделенную память
	free(str_res);
	for (int i = 0; i < n; i++) free(*(str + i));
	free(str);
	return 0;
}


//int Repeat(char** st, char* st_res, char* st_dop, int s_str, int s_stl)
//{
//	int i = 0, j = 0, i_dp = 0, i_res = 0, ii, jj;
//	int kol_dop = 0, kol_org = 0, match_w = 0, kol_res = 0;
//	while (i < s_str)
//	{
//		i_dp = 0;                               //становимся в начало доп. строки
//		while (*(*(st + i) + j) == ' ') j++;    //цикл пропуска пробелов
//		i_res = 0;                              //обнуляем переменнную прохода по результирующей строке
//		while (*(*(st + i) + j) != ' ' && *(*(st + i) + j) != '\n')   //цикл прохода по слову
//		{
//			kol_org++;                                       //счётчик количества букв в найденном слове
//			*(st_dop + i_dp++) = *(*(st + i) + j);           //заполнение доп. строки символами слова из исходной строки
//			j++;                                             //переход к следующему символу в исх. строке
//			if (*(st_dop + i_dp - 1) == *(st_res + i_res) && kol_res > 0) //найдено совпадение символов
//			{                                     //проверяем, не записано ли данное слово уже в рез. строку
//				if (i_dp - 2 > 0) i_dp = 0;       //обнуление переменной движения по доп. строке, если в ней уже были символы кроме совпавших
//				i_res++;                          //переход к след. символу в рез. строке 
//				if (i_res == kol_res - 1 && (*(st_res + i_dp) == ' ' || *(st_res + i_dp) == '\n')) //все символы в строках совпали
//				{                                         //значит, одинак. слов в исх. строке 3 и более
//					i_dp = 0;                             //обнуляем переменную движения по доп. строке
//				} 
//			}
//		}
//		*(st_dop + i_dp) = '\0';                    //ставим нуль-символ в конец строки
//		i_dp = 0;                                   //становимся в начало доп. строки для повторного прохода по нему
//		if (*(*(st + i) + j) == '\n')               //если достигнут символ перехода на новую строку в тексте 
//		{
//			i++;                                    //переход на новую строку массива строк
//			j = 0;                                  //становимся в её начало
//		}
//		ii = i; jj = j;                            //запоминаем место, с которого искать повторяющиеся слова
//
//		while (ii < s_str)
//		{
//			if (*(st_dop + i_dp) == '\0' && i_dp == 0)  //в строке 3 и более раз повторяется одно слово
//			{                                           //тогда выходим из цикла поиска
//				break;                                  //чтобы не записывать в рез. строку слово, которое
//			}                                           //в ней уже есть
//			while (*(st_dop + i_dp) - *(*(st + ii) + jj) == 0 && *(st_dop + i_dp) && *(*(st + ii) + jj) != '\n')
//			{
//				if (jj > 0 && i_dp == 0 && *(st_dop + i_dp)) //проверка на вхождение искомого слова в другое слово
//				{
//					if (*(*(st + ii) + jj - 1) != ' ')  //предыдущий символ слова не пробел, хотя в доп. строке стоим
//					{                                   //на первом символе слова
//						kol_dop = 0;                    //обнуляем счётчик количества совпавших символов, чтобы его сбить
//						i_dp++;                         
//						jj++;
//						continue;
//					}
//				}
//				i_dp++;            //переход к след. символу в доп. строке
//				kol_dop++;         //счётчик совпадений символа из доп. строки с символом в исходной строке
//				jj++;              //переход к след. символу с исходной строке
//		}
//			if ((*(*(st + ii) + jj) == ' ' || *(*(st + ii) + jj) == '\n') && kol_dop == kol_org)
//			{
//				i_res = kol_res;                                        //ставим i_res в правильную позицию, чтобы не перезаписывать уже записанные в ней слова
//				i_dp = 0;
//				while (*(st_dop + i_dp))
//				{
//					*(st_res + i_res++) = *(st_dop + i_dp++);
//					kol_res++;                                          //счётчик количества букв в рез. массиве для определения
//				}                                                        
//				*(st_res + i_res) = ' ';                                //ставим пробел после слова
//				i_res++; kol_res++; *(st_res + i_res) = '\0';           //ставим нуль-символ в конец строки
//				kol_dop = 0;                                            //обнуляем счётчик совпавших букв
//				match_w++;                                              //счётчик кол-ва записанных одинаковых слов
//				break;                                                  //выход из цикла, чтобы не было записи того же слова 
//			}                                                           //если таковое имеется в дальнейшем в строке
//			if (*(st_dop + i_dp) - *(*(st + ii) + jj) != 0)       //нет совпадений символов
//			{ 
//				i_dp = 0;                                        //становимся в начало доп. строки
//				kol_dop = 0;                                     //обнуляем кол-во совпадений символов
//				jj++;                                            //переход к след. символу исходной строки 
//			}
//
//			if (!*(*(st + ii) + jj))        //достигнут конец строки в массиве строк
//			{
//				ii++;                       //переход к след. строке
//				jj = 0;                     //становимся в её начало
//			}
//		}
//		kol_org = 0;                //сброс счётчика букв искомого слова
//	}
//	return match_w;
//}


int Repeat(char** st, char* st_res, char* st_dop, int s_str, int s_stl)
{
	int i = 0, j = 0, j_start = 0, i_start = 0, j_end = 0, jd_start = 0, id_start = 0, jd_end = 0, i_res = 0, ii, jj, in_res = 0;
	int kol_dop = 0, kol_org = 0, match_w = 0, kol_res = 0;
	bool more_t = 0;
	while (i < s_str)
	{
		while (*(*(st + i) + j) == ' ') j++;    //цикл пропуска пробелов
		j_start = j; i_start = i;               //запоминаем начало слова 
		i_res = in_res;                        //становимся в начало последнего записанного слова в рез. строке
		while (*(*(st + i) + j) != ' ' && *(*(st + i) + j) != '\n')   //цикл прохода по слову
		{
			kol_org++;                                                               //счёт кол-ва букв в слове
			if (*(st_res + i_res) == *(*(st + i) + j) && *(st_res + i_res) != ' ')   //проверка на нахождение в исх. массиве слова из рез. строки
			{
				if (i_res == 0 && j > 0 && *(*(st + i) + j - 1) != ' ') more_t = 0;  //слово включает в себе слово из рез. строки, но им не является
				if (*(st_res + i_res + 1) == ' ' && (*(*(st + i) + j + 1) == ' ' || *(*(st + i) + j + 1) == '\n')) //все символы совпали
				{                                                                    //значит, в исх. строке есть ещё одно слово из рез. строки
					more_t = 1;                                                      //переменная наличия полностью совпашего слова
				}
				i_res++;                                                             //переход к след. символу в рез. строке  
			}
			j++;                                                                     //переход к след. символу в исх. строке
		}
		j_end = j;                                                             //запоминаем конец слова
		if (*(*(st + i) + j) == '\n')               //если достигнут символ перехода на новую строку в тексте 
		{
			i++;                                    //переход на новую строку массива строк
			j = 0;                                  //становимся в её начало
		}
		ii = i; jj = j;                            //запоминаем место, с которого искать повторяющиеся слова
		jd_start = j_start; id_start = i_start;    //запоминаем начало слова, чтобы проходить по нему во время поиска в ост. части строки

		while (ii < s_str)
		{
			if (more_t)    //такое слово уже есть в рез. строке
			{                                           
				break;     //выходим из цикла поиска                             
			}                                           
			while (*(*(st + id_start) + jd_start) - *(*(st + ii) + jj) == 0 && *(*(st + ii) + jj) != '\n' && jd_start < j_end) //проверка на совпадение символов
			{
				if (jj > 0 && jd_start == j_start && *(*(st + ii) + jj - 1) != ' ')  //слово состоит из искомого, но не является им
				{
					jd_start = 0; kol_dop = 0; jj++;                                 //сбиваем переменные, чтобы сбить алгоритм записи в рез. строку
					continue; 
				}
				jj++; jd_start++; kol_dop++;                                         //счёт сиволов в слове, переход к след. символам

			}
			if ((*(*(st + ii) + jj) == ' ' || *(*(st + ii) + jj) == '\n') && kol_dop == kol_org)  //найдено совпадение
			{
				i_res = kol_res;                                        //ставим i_res в правильную позицию, которая мной сбивалась
				in_res = i_res;
				jd_start = j_start; id_start = i_start;                 //возвращаемся в начало искомого слова
				while (jd_start < j_end)
				{
					*(st_res + i_res++) = *(*(st + id_start) + jd_start++);   //заполнение рез. строки
					kol_res++;                                                //счётчик количества букв в рез. массиве для определения
				}
				*(st_res + i_res) = ' ';                                 //ставим пробел после слова
				i_res++; kol_res++; *(st_res + i_res) = '\0';            //ставим нуль-символ в конец строки
				kol_dop = 0;                                             //обнуляем счётчик совпавших букв
				match_w++;                                               //счётчик кол-ва записанных слов в рез. массив
				break;                                                   //выход из цикла, чтобы не было записи того же слова 
			}                                                            //если таковое имеется в дальнейшем в строке
			if (*(*(st + id_start) + jd_start) - *(*(st + ii) + jj) != 0)   //нет совпадения символов
			{
				jd_start = j_start;                              //становимся в начало искомого слова
				kol_dop = 0;                                     //обнуляем кол-во совпадений символов
				jj++;                                            //переход к след. символу исходной строки 
			}
			if (!*(*(st + ii) + jj))        //достигнут конец строки в массиве строк
			{
				ii++;                       //переход к след. строке
				jj = 0;                     //становимся в её начало
			}
		}
		more_t = 0; kol_org = 0;            //обнуление счётчика букв в искомом слове и переменной наличия совпавших слов в исх. и рез. строках
	}
	return match_w;                //возвращаем кол-во записанных слов в рез. строку
}
